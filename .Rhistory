library(lazyeval)
expr_text
expr_find
lazyeval_expr_find_
f <- ~ x + y + z
typeof(f)
attributes(f)
length(f)
f[[1]]
f[[2]]
g <- y ~ x + z
typeof(g)
f[[1]]
g[[1]]
g[[2]]
g[[3]]
length(g)
f_env(f)
f_env(g)
f_rhs(f)
f_lhs(f)
f_lhs(g)
f_rhs(g)
f <- ~ 1 + 2 + 3
f
f[[2]]
f_eval(f)
x <- 1
add_1000 <- function(x) {
~ 1000 + x
}
add_1000(3)
# need to use the f_eval to evaluation the function
f_eval(add_1000(3))
# use the f_unwrap() to see what is going on inside the formula
f_unwrap(add_1000(3))
y <- 100
f_eval(~y)
f_eval(~y, data = list(y = 10))
# So you can mix variables in this environment and add data arguments
f_eval(~ x + y, data = list(x - 10))
# can even use functions
f_eval(~f(y), data = list(f = function(x) x * 3))
f_unwrap(~f(y), data = list(f = function(x) x * 3))
f_unwrap(~f(y))
f_unwrap(~f(y))
f_eval(~f(y))
f_eval(~y)
f_eval(~x)
x
ls()
str(ls())
attributes(ls())
# This leads to non-stanard scoping
f_eval(~ mean(cyl), data = mtcars)
# Cannot tell, so f_eval() has two pronouns: .data and .env
# Can use these pronounds to rewrite the previous formula to remove ambiguity
mydata <- data.frame(x = 100, y = 1)
x <- 10
f_eval(~ .env$x, data = mydata)
f_eval(~ .data$x, data = mydata)
# If the variable or object doesn't exist, you get an error
f_eval(~ .env$z, data = mydata)
f_eval(~ .env$x)
f_eval(~ .data$xm data = mydata)
f_eval(~ .data$x, data = mydata)
f_eval(~ .data$z, data = mydata)
df_mean <- function(df, varaible) {
f_eval(~ mean(uq(variable)), data = df)
}
df_mean(mtcars, ~ cyl)
df_mean(mtcars, ~ cyl)
library(tidyverse
)
df_mean(mtcars, ~ cyl)
df_mean <- function(df, variable) {
f_eval(~ mean(uq(variable)), data = df)
}
df_mean(mtcars, ~ cyl)
df_mean(mtcars, ~ cyl)
df_mean(mtcars, ~ disp * 0.01638)
df_mean(mtcars, ~ sqrt(mpg))
# How does this work? Use the f_interp() to show
variable <- ~ cyl
str(variable)
f_interp(~ mean(uq(variable)))
# Unquoting allows you to create a code of templates
f <- ~ mean
length(f)
f[[1]]
f[[2]]
f_inter(~ uq(f)(uq(variable)))
f_interp(~ uq(f)(uq(variable)))
variable <- ~ disp * 0.01638
f_interp(~ uq(f)(uq(variable)))
# NOTES: uq() on takes the RHS of a formula; use uqf() to use the whole formula
formula <- y ~ x
f_interp(~lm(uq(formula), data = df)
f_interp(~lm(uq(formula), data = df)
)
f_interp(~lm(uq(formula), data = df))
with
with()
help("with")
# IF you need extra arguments, use the uqs() -- unquote-splice
variable <- ~ x
extra_args <- list(na.rm = TRUE, trim = 0.9)
str(extra_args)
typeof(extra_args)
extra_args
f_interp(~ mean(uq(variable), uqs(extra_args)))
x
f_eval(~mean(uq(variable), uqs(extra_args)))
lm()
?lm()
names(mtcars)
lm(mpg ~ disp, data = mtcars)
uq(variable)
sieve <- function(df, condition) {
rows <- f_eval(condition, df)
if(!is.logical(rows)) {
stop("`condition' must be logical.", call. = FLASE)
}
rows[is.na(rows)] <- FALSE
df[rows, , drop = FALSE]
}
sieve()
df <- data.frame(x = 1:5, y = 5:1)
sieve(df, ~x <= 2)
sieve(df, ~ x + y)
sieve <- function(df, condition) {
rows <- f_eval(condition, df)
if(!is.logical(rows)) {
stop("`condition' must be logical.", call. = FALSE)
}
rows[is.na(rows)] <- FALSE
df[rows, , drop = FALSE]
}
sieve
sieve()
is.logical(f_eval(~ x + y, df))
is.logical(f_eval(~ x <= 2, df))
# Broom and dplyr
library(broom)
library(tidyverse)
data(Orange)
dim(Orange)
Hmisc::describe(Orange)
str(Orange)
levels(Orange$Tree)
# Check correlation between variables
Orange %>%
cor(age, circumference)
# Check correlation between variables
Orange %>%
cor(age, circumference)
# Check correlation between variables
cor(Orange$age, Orange$circumference)
# Check correlation between variables
(cor(Orange$age, Orange$circumference))
ggplot(Orange, aes(age, circumference, color = Tree)) +
geom_line()
# Check for group correlations
Orange %>%
group_by(Tree) %>%
summarize(correlation = cor(age, circumference))
# Summarize information about each test
Orange %>%
group_by(Tree) %>%
do(tidy(cor.test(.$age, .$circumference)))
# In a regression model
Orange %>%
group_by(Tree) %>%
do(tidy(lm(age ~ circumference, data = .)))
# With multiple variables
mtcars %>%
group_by(am) %>%
do(tidy(lm(wt ~ mpg + qsec + gear, .)))
# With multiple variables
rgr <- mtcars %>%
group_by(am) %>%
do(tidy(lm(wt ~ mpg + qsec + gear, .)))
# With multiple variables
rgr <-
mtcars %>%
group_by(am) %>%
do(tidy(lm(wt ~ mpg + qsec + gear, .)))
rgr
# With multiple variables
rgr <-
mtcars %>%
group_by(cyl) %>%
do(tidy(lm(wt ~ mpg + qsec + gear, .)))
rgr
rgr_fit <-
mtcars %>%
group_by(cyl) %>%
do(fit(lm(wt ~ mpg + qsec + gear, .)))
rgr_fit <-
mtcars %>%
group_by(cyl) %>%
do(fit = lm(wt ~ mpg + qsec + gear, .))
rgr_fit
rgr %>% tidy(fit)
rgr_fit %>% tidy(fit)
rgr_fit %>% argument(fit)
rgr_fit %>% augument(fit)
rgr_fit %>% augment(fit)
library(purrr)
library(ggplot2)
library(dplyr)
library(broom)
library(knitr)  # for kable
data(Fair, package = "Ecdat") # extramarital affairs dataset
glimpse(Fair)
install.packages("Ecdat")
library(purrr)
library(ggplot2)
library(dplyr)
library(broom)
library(knitr)  # for kable
data(Fair, package = "Ecdat") # extramarital affairs dataset
glimpse(Fair)
# Now run a regression where you exclude the outcome variable, and do an interative regression across the remaining values
r2s <-
Fair %>%
select(-nbaffairs) %>%
map(~ lm(Fair$nbaffairs ~ .x, data = Fair)) %>%
map(summary) %>%
map_dbl("r.squared") %>%
tidy %>%
arrange(desc(x))%>%
rename(r.squared = x)
kable(r2s)
lml <- lm(nbaffairs ~ rate, data = Fair)
summary(lml)
r2s
# Can now plot the results from the original call
ggplot(r2s, aes (x = reorder(names, r.squared), y = r.squared)) +
geom_point(size = 5, colour = "blue")
# Keep both p-values instead
ps <-
Fair %>%
dplyr::select(-nbaffairs) %>%  # exclude outcome, leave only predictors
map(~lm(Fair$nbaffairs ~ .x, data = Fair)) %>%
map(summary) %>%
map(c("coefficients")) %>%
map_dbl(8)  %>% # 8th element is the p-value
tidy %>%
dplyr::arrange(desc(x)) %>%
rename(p.value = x)
ps
kable(ps)
# Keep both p-values instead
ps <-
Fair %>%
dplyr::select(-nbaffairs) %>%  # exclude outcome, leave only predictors
map(~lm(Fair$nbaffairs ~ .x, data = Fair)) %>%
map(summary) %>%
map(broom::tidy) %>%
map_df("p.value")  %>%
round(3) %>%
mutate(variable = c("intercept", "predictor"))
ps
# extracting coefficients from a model
data(iris)
lm(Sepal.Width ~ Species, data = iris) %>%
tidy()
reg_model <- lm(Sepal.Width ~ Species, data = iris) %>%
tidy()
# To get residuals, use the augment argument
reg_model %>% augment(.)
# To get residuals, use the augment argument
reg_model %>% augment()
# To get residuals, use the augment argument
lm(Sepal.Width ~ Species, data = iris) %>%
augment()
# To get residuals, use the augment argument
lm(Sepal.Width ~ Species, data = iris) %>%
augment() %>% head()
reg_model <- lm(Sepal.Width ~ Species, data = iris) %>%
tidy()
# Use glance to extract measures of fit
reg_model <- lm(Sepal.Width ~ Species, data = iris) %>%
glance()
# Use glance to extract measures of fit
lm(Sepal.Width ~ Species, data = iris) %>%
glance()
factors(letters)
factor(letters)
# All factors -------------------------------------------------------------
df <- data.frame(x = seq(1:26))
df
df$letters <- factor(letters)
df
str(df)
?rnorm()
# All factors -------------------------------------------------------------
df <- data.frame(x = seq(1:26), y = rnorm(100, mean = 50, sd = 1))
# All factors -------------------------------------------------------------
df <- data.frame(x = seq(1:26), y = rnorm(26, mean = 50, sd = 1))
df
# All factors -------------------------------------------------------------
df <- data.frame(x = seq(1:26), y = rnorm(26, mean = 10, sd = 1))
df$letters <- factor(letters)
str(df)
# Check if a variable is a factor
is.factor(df$letters)
is.factr(df$y)
is.factor(df$y)
# Create an orderd factor
factors(letters, ordered = FALSE)
# Create an orderd factor
factor(letters, ordered = FALSE)
# Check if a factor is indeed ordered
is.ordered(factor(letters))
# Create an orderd factor
factor(letters, ordered = TRUE)
# Create a new factor level
a <- factor(letters[1:5])
str(a)
levels(a) <- c(levels(a), "new_level")
a
